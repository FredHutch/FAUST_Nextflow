#' Full Annotation Using Shape-constrained Trees
#'
#' This function discovers and annotated cell subsets in experimental cytometry data stored in a gating set.
#' 
#' @param gatingSet The `faust` function requires that experimental cytometry data you wish to analyze
#' is stored in a `GatingSet` data structure.
#' This data structure can be constructed available using the `flowWorkspace` Bioconductor package.
#' 
#' @param activeChannels A character vector, each entry of which is a marker name to be used in the `faust`
#' analysis. The markers listed in this parameter
#' must **exactly** match the `desc` field of the `parameters` of the `flowFrames` in the `GatingSet.
#' `FAUST` will not run if they do not match exactly.
#' 
#' @param channelBounds A 2 by `length(activeChannels)` numeric matriix,
#' with `colnames(channelBounds) <- activeChannels` and `rownames(channelBounds) <- c("Low","High")`.
#' Expression values in a channel less than or equal to the value in the "Low"
#' row are treated as low, by default, and not actively considered when `FAUST` processes the data.
#' Expression values in a channel greater than or equal to the value in the "High"
#' row are treated as high, by default, and not actively considered when `FAUST` processes the data.
#' If this parameter is not set by the user, it will be set empirically by heuristic, and printed to log.
#' 
#' @param startingCellPop A character vector specifying the node from the manual gating strategy attached to
#' the `gatingSet` to use for `faust` analysis. The node in the manual gating strategy is, at minimum,
#' asusmed by `faust` to have pre-gated debris and dead cells. For example, the node might identify live lymphocytes
#' in each sample.
#' 
#' @param experimentalUnit A character vector specifying the experimental unit of analysis of samples contained
#' in the gating set. If left as its default value "", the "name" column in `pData(gatingSet)` will be used as
#' the experimental unit, leading to `FAUST` analyzing each sample independently. If modified by the user, the
#' value must match one of the strings in `colnames(pData(gatingSet))`; the corresponding column of the
#' data frame `pData(gatingSet)` will be used to concatenate individual samples into experimental units for analysis
#' by `FAUST`.
#'
#' @param imputationHierarchy A character vector specifying the imputation hierarchy for annotation boundaries computed
#' by FAUST. If left as its default value "", `FAUST` will impose no hierarchy on the data.
#' If modified by the user, the value must match one of the strings in `colnames(pData(gatingSet))`;
#' the corresponding column of the data frame `pData(gatingSet)` will be used to impose the impose the imputation
#' hierarchy: for each selected marker, experimental units that do not empirical support annotation bondaries for a marker
#' will first attempt to use other experimental units with the same `imputationHierarchy` coding to impute boundaries.
#' If this is not possible, annotation boundaries will be imputed usining boundaries from all experimental units.
#' 
#' @param projectPath An absolute path on your system that locates all intermediate data produced by faust.
#' At the location specified by the projectPath, `faust` creates a directory called `faustData`, and subdirectories
#' that contain intermediate data generated by the analysis. The final output of `faust`, an annotated matrix of
#' counts, is produced at `projectPath/faustData/faustCountMatrix.rds`, and can be loaded into R using the `readRDS`
#' function. Currently, `faust` only supports Mac OSX and Linux file systems.
#' 
#' @param depthScoreThreshold A numeric value between 0 and 1 used for marker selection.
#' `faust` uses this parameter in conjunction with the `selectionQuantile` parameter to determine which
#' markers to use for discovery and annotation. 
#' `faust` automatically produces a plot "projectPath/faustData/plotData/scoreLines.pdf"
#' that can be used to help set this threshold value for an experiment.
#'
#' @param selectionQuantile A numeric value between 0 and 1 used for marker selection.
#' Depth scores are computed for all experimental units in the experiment.
#' FAUST computes the empirical selectionQuantile  across each channel:
#' `quantile(channelDepthScores,probs=selectionQuantile)`.
#' The empirical quantile is then compared to the depthScoreThreshold for each marker.
#' All markers with empirical quantile above the depthScoreThreshold are used by `faust` to discover
#' and annotate cell subsets in the experiment.
#'
#' @param debugFlag Boolean value. Set to TRUE to print method status information to the console or a log file.
#'
#' @param threadNum Integer value. Many components of the FAUST method support multi-threading on a single CPU.
#' Set this parameter to the number of threads you wish to use.
#'
#' @param seedValue Integer value that determines the random seed. Used for reproducibility.
#'
#' @param numForestIter The number of annotation forest grown for each experimental unit. Set to 1 by default.
#'
#' @param numScampIter The number of SCAMP iterations run at the discovery stage. Set to 1 by default.
#'
#' @param nameOccuranceNum The number of times a name has to appear in distinct SCAMP clusterings to be
#' gated out.
#' 
#' @param supervisedList A list of lists.
#' The names of list entries correspond to marker names in the active channels vector. 
#' Channels named in this list will have their gate locations modified. See Details.
#'
#' @param annotationsApproved Boolean value. FALSE by default to encourage the
#' user to review the proposed annotation boundaries. When set to TRUE, indicates the user
#' wants to use the proposed annotation boundaries to cluster and gate the experiment.
#' If you want to run the FAUST method totally unsupervised, set this parameter to true
#' before running the method.
#'
#' @param drawAnnotationHistograms Boolean. Set to 1 to draw the annotation boundary locations for selected markers
#' for all samples and all markers. Set to 0 to forego the plotting.
#' 
#' @param densitySubSampleThreshold Integer value. 
#' Sets the number of cells needed in a clustering collection to sub-sample for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. Gating at the end of the pipeline 
#' 
#' @param densitySubSampleSize Integer value.
#' The number of cells to sub-sample from a clustering collection for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. Gating at the end of the pipeline 
#' 
#' @param densitySubSampleIterations Integer value.
#' The number of distinct sub-sampled density estimates to compute. The final gate location is the median
#' across the sub-sampled densities.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. Gating at the end of the pipeline 
#'
#' @param archDescriptionList list containing slot "targetArch".
#' Default "singleCPU" indicates FAUST will run on a single processor.
#' Set "targetArch" slot to "slurmCluster" to dispatch jobs across a cluster managed by slurm.
#' When "tagertArch" is set to "slurmCluster", several other slots must be set by the user.
#' maxNodeNum: the maximum number of nodes you wish to request on the slurm cluster.
#' maxTime: the total amount of time you want to run FAUST for. When exceeded, the job terminates.
#' sbatchFlags: a character string containing the flags to pass to sbatch.
#' nodeThreadNum: number of threads requested on each node.
#' @return The FAUST pipeline returns a null value on completion. The main output is the file
#' "projectPath/faustData/faustCountMatrix.rds". The rownames are `sampleNames(gatingSet)]`
#' and the column names are the cell populations discovered by the pipeline. Note that the
#' special cell population "0_0_0_0_0" counts unclassified cells in the experiment.
#' @importFrom cowplot save_plot plot_grid ggdraw draw_label get_legend
#' @importFrom tidyr gather
#' @importFrom stats quantile runif mad median qt sd weighted.mean
#' @importFrom flowWorkspace load_gs getData sampleNames
#' @importFrom flowCore exprs parameters
#' @importFrom Biobase AnnotatedDataFrame
#' @importFrom Biobase pData
#' @importFrom scamp scamp
#' @importFrom whisker whisker.render
#' @importFrom utils read.table globalVariables
#' @importFrom data.table fwrite
#' @importFrom viridis magma viridis
#' @importFrom grDevices nclass.FD
#' @importFrom ggplot2 ggplot aes theme_bw geom_hex geom_vline geom_hline xlab ylab theme ggtitle scale_color_manual scale_linetype_manual geom_histogram geom_line
#' @examples
#'
#' library(BiocManager)
#' BiocManager::install("flowWorkspaceData")
#' \dontrun{
#' faust(gatingSetPath=clusterMatrix,
#'                          numIter=1,
#'                          projectPath=tempdir())
#' table(scampClustering$RunOffVote)
#' table(scampClustering$MaxVote)
#' }
#' @export
#' @md
faust <- function(gatingSet,
                  activeChannels,
                  channelBounds="",
                  startingCellPop,
                  experimentalUnit="",
                  imputationHierarchy="",
                  projectPath=".",
                  depthScoreThreshold=0.01,
                  selectionQuantile=0.50,
                  debugFlag=FALSE,
                  threadNum=1,
                  seedValue=123,
                  numForestIter=1,
                  numScampIter=1,
                  nameOccuranceNum=ceiling((0.1*length(gatingSet))),
                  drawAnnotationHistograms=1,
                  supervisedList=NA,
                  annotationsApproved=FALSE,
                  densitySubSampleThreshold=1e9,
                  densitySubSampleSize=1e9,
                  densitySubSampleIterations=1,
                  archDescriptionList=list(targetArch=c("singleCPU"))
                  )
{
    #test parameters. stop if invalid. initialize faustData.
    .validateParameters(
        activeChannels = activeChannels,
        channelBounds = channelBounds,
        startingCellPop = startingCellPop,
        projectPath = projectPath,
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        debugFlag = debugFlag,
        threadNum = threadNum,
        seedValue = seedValue,
        numForestIter = numForestIter,
        numScampIter = numScampIter,
        supervisedList = supervisedList,
        annotationsApproved = annotationsApproved,
        densitySubSampleThreshold = densitySubSampleThreshold,
        densitySubSampleSize = densitySubSampleSize,
        densitySubSampleIterations = densitySubSampleIterations
    )
    
    #construct the analysis map directly from gating set
    gspData <- pData(gatingSet)
    if ((experimentalUnit == "") || (!(experimentalUnit %in% colnames(gspData)))) {
        analysisMap <- data.frame(
            sampleName = sampleNames(gatingSet),
            analysisLevel = sampleNames(gatingSet),
            stringsAsFactors = FALSE
        )
    }
    else {
        analysisMap <- data.frame(
            sampleName = sampleNames(gatingSet),
            analysisLevel = gspData[,experimentalUnit,drop=TRUE],
            stringsAsFactors = FALSE
        )
    }
    if ((imputationHierarchy=="") || (!(imputationHierarchy %in% colnames(gspData)))) {
        analysisMap$impH <- "allSamples"
    }
    else {
        analysisMap$impH <- as.character(gspData[,imputationHierarchy,drop=TRUE])
    }
    if (debugFlag) {
        print("impH")
        print(table(analysisMap$impH))
    }
    #test to see if the analysis map has changed
    if (!file.exists(paste0(projectPath,"/faustData/metaData/analysisMap.rds"))) {
        saveRDS(analysisMap,paste0(projectPath,"/faustData/metaData/analysisMap.rds"))
    }
    else {
        oldAnalysisMap <- readRDS(paste0(projectPath,"/faustData/metaData/analysisMap.rds"))
        if (!identical(oldAnalysisMap,analysisMap)) {
            if (nrow(oldAnalysisMap) != nrow(analysisMap)) {
                print("The number of samples has changed between faust runs.")
                stop("Please start a new projectPath to analyze a different collection of samples.")
            }
            else {
                print("The sample grouping derived from experimentalUnit has changed between faust runs.")
                stop("Please start a new projectPath to analyze a different concatenation of samples.")
            }
        }
    }
    
    #test to see if the channel bounds have changed.
    if (!file.exists(paste0(projectPath,"/faustData/metaData/channelBounds.rds"))) {
        saveRDS(channelBounds,paste0(projectPath,"/faustData/metaData/channelBounds.rds"))
    }
    else {
        #if the channel bounds exist already, the faust pipeline has been run at least once.
        #check to see if any modifications have been made to the channel bounds.
        oldChannelBounds <- readRDS(paste0(projectPath,"/faustData/metaData/channelBounds.rds"))
        if ((!identical(oldChannelBounds,channelBounds)) &&
            (file.exists(paste0(projectPath,"/faustData/metaData/bigForestDone.rds")))) {
            if (debugFlag) print("Detected change to channelBounds.")
            file.remove(paste0(projectPath,"/faustData/metaData/bigForestDone.rds"))
            file.remove(paste0(projectPath,"/faustData/metaData/channelBounds.rds"))
            uniqueLevels <- unique(analysisMap[,"analysisLevel"])
            #delete flags for levels with annotation forests in order to regrow them.
            #also delete flags for scamp clsuterings to relabel data.
            for (analysisLevel in uniqueLevels) {
                if (file.exists(paste0(projectPath,"/faustData/levelData/",analysisLevel,"/aLevelComplete.rds"))) {
                    file.remove(paste0(projectPath,"/faustData/levelData/",analysisLevel,"/aLevelComplete.rds"))
                }
                if (file.exists(paste0(projectPath,"/faustData/levelData/",analysisLevel,"/scampALevelComplete.rds"))) {
                    file.remove(paste0(projectPath,"/faustData/levelData/",analysisLevel,"/scampALevelComplete.rds"))
                }
            }
            if (file.exists(paste0(projectPath,"/faustData/metaData/parsedGS.rds"))) {
                file.remove(paste0(projectPath,"/faustData/metaData/parsedGS.rds"))
            }
            if (file.exists(paste0(projectPath,"/faustData/metaData/firstALReady.rds"))) {
                file.remove(paste0(projectPath,"/faustData/metaData/firstALReady.rds"))
            }
            saveRDS(channelBounds,paste0(projectPath,"/faustData/metaData/channelBounds.rds"))
        }
    }

    #begin method processing. copy data to projectPath from gatingSet.
    if (debugFlag) print("Begin data extraction.")
    .extractDataFromGS(
        gs = gatingSet,
        activeChannels = activeChannels,
        startingCellPop = startingCellPop,
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    if (debugFlag) print("Making restriction matrices.")
    .makeRestrictionMatrices(
        samplesInExp = flowWorkspace::sampleNames(gatingSet),
        analysisMap = analysisMap,
        channelBounds = channelBounds,
        projectPath = projectPath,
        debugFlag = debugFlag
    )
    
    #accumulate data into the analysis levels.
    if (debugFlag) print("Begin first analysis level prep.")
    .prepareFirstAL(
        analysisMap = analysisMap,
        projectPath = projectPath
    )

    #sanitize the starting cell pop for problem characters.
    startingCellPop <- gsub("[[:punct:]]","",startingCellPop)
    startingCellPop <- gsub("[[:space:]]","",startingCellPop)
    startingCellPop <- gsub("[[:cntrl:]]","",startingCellPop)
    
    #start the annotation process
    if (!file.exists(paste0(projectPath,"/faustData/metaData/bigForestDone.rds"))) {
        #in large experiments, this can be a costly step without sub-sampling.
        #often we will want to supervise the results after growing the forest,
        #so only grow it on an as-need basis
        .growAnnForest(
            rootPop = startingCellPop,
            activeChannels = activeChannels,
            analysisMap = analysisMap,
            numIter = numForestIter,
            debugFlag = debugFlag,
            threadNum = threadNum,
            seedValue = seedValue,
            projectPath = projectPath,
            densitySubSampleThreshold = densitySubSampleThreshold,
            densitySubSampleSize = densitySubSampleSize,
            densitySubSampleIterations = densitySubSampleIterations,
            archDescriptionList=archDescriptionList
        )
        bigForestDone <- TRUE
        saveRDS(bigForestDone,paste0(projectPath,"/faustData/metaData/bigForestDone.rds"))
    }
    
    if (debugFlag) print("Selecting standard set of channels across experiment using depth score.")
    selC <- .selectChannels(
        parentNode = startingCellPop,
        analysisMap = analysisMap,
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        projectPath = projectPath
    )
    saveRDS(selC,paste0(projectPath,"/faustData/metaData/initSelC.rds"))    

    if (!length(selC)) {
        print("No channels selected at current settings.")
        stop("Modify faust parameters: incease selectionQuantile, decrease depthScoreThreshold.")
    }

    manualList <- forceList <- selectionList <- preferenceList <- list()
    if (!is.na(supervisedList)) {
        #supervisedList is a named list of lists
        #name of slot in list: marker
        #list under marker slot 1: string describing type of supervision.
        #list under marker slot 2: vector of ints dictating supervision action.
        supervisedMarkers <- names(supervisedList)
        for (markerNum in seq(length(supervisedMarkers))) {
            marker <- supervisedMarkers[markerNum]
            markerList <- supervisedList[[markerNum]]
            actionType <- markerList[[1]]
            action <- markerList[[2]]
            if (actionType == "Preference")  {
                preferenceList <- append(preferenceList,list(action))
                names(preferenceList)[length(preferenceList)] <- marker
            }
            else if (actionType == "PostSelection")  {
                selectionList <- append(selectionList,list(action))
                names(selectionList)[length(selectionList)] <- marker
            }
            else if (actionType == "Force") {
                forceList <- append(forceList,list(action))
                names(forceList)[length(forceList)] <- marker
            }
            else if (actionType == "Manual") {
                manualList <- append(manualList,list(action))
                names(manualList)[length(manualList)] <- marker
            }
            else {
                print(paste0("Requested unsupported supervision type for marker ", marker))
                print("Only 'Preference' and 'PostSelection' supervision types are currently supported.")
                print(paste0("Ignoring requested action: ",actionType))
            }
        }
    }

    if (debugFlag) print("Reconciling annotation boundaries across experiment.")
    .reconcileAnnotationBoundaries(
        selectedChannels = selC,
        parentNode = startingCellPop,
        analysisMap = analysisMap,
        projectPath = projectPath,
        debugFlag = debugFlag,
        preferenceList = preferenceList,
        forceList = forceList,
        manualList = manualList
    )
    
    if ((!is.na(supervisedList)) && (length(selectionList) > 0)){
        if (debugFlag) print("Selection specific reconciled annotation boundaries.")
        .superviseReconciliation(
            supervisedList = selectionList,
            parentNode = startingCellPop,
            projectPath = projectPath
        )
    }
    else {
        file.copy(from = paste0(projectPath,"/faustData/gateData/",startingCellPop,"_resListPrep.rds"),
                  to = paste0(projectPath,"/faustData/gateData/",startingCellPop,"_resList.rds"),
                  overwrite = TRUE)
    }
    
    if (debugFlag) print("Writing annotation matrices to file.")
    .mkAnnMats(
        parentNode = startingCellPop,
        analysisMap = analysisMap,
        projectPath = projectPath
    )
    
    if (debugFlag) print("Generating depth score plot.")
    .plotScoreLines(
        projectPath = projectPath,
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        forceList = forceList
    )

    if (debugFlag) print("Generating marker boundary histograms.")
    .plotMarkerHistograms(
        analysisMap = analysisMap,
        startingCellPop = startingCellPop,
        projectPath = projectPath
    )

    if (drawAnnotationHistograms) {
        if (debugFlag) print("Generating annotation boundary histograms.")
        for (sampleName in analysisMap[,"sampleName"]) {
            .plotSampleHistograms(
                sampleName = sampleName,
                analysisMap = analysisMap,
                startingCellPop = startingCellPop,
                projectPath = projectPath
            )
        }
    }
    
    if (!annotationsApproved) {
        print("********************************************************")
        print("Channels have been selected on the basis of the depth score at the specified selection quantile.")
        print("Annotation boundaries have been generated for all selected channels.")
        print(paste0("Plots have been written to file in the directory ",
                     projectPath,"/faustData/plotData"))
        print("")
        print("Review these plots to ensure all desired channels have been selected.")
        print("If too many/too few channels have been selected, modify the parameters")
        print("depthScoreThreshold and selectionQuantile.")
        print("")
        print(paste0("Also review the annotation boundaries displayed on the sample-level histograms in",
                     projectPath,"/faustData/plotData/histograms"))
        print("If you wish to modify the placement of the annotation boundaries,")
        print("change the parameters initSplitPval and supervisedList.")
        print("")
        print("Changing the Low/High values in the channelBounds matrix will also affect")
        print("the placement of annotation boundaries. It is the most effective way to directly modify")
        print("their placement. However, when you modify the Low/High values in the channelBounds matrix,")
        print("the FAUST pipeline will regrow the entire annotation forest.")
        print("")
        print("Once you are satisfied with the annotation boundary placement, set the parameter")
        print("annotationsApproved=TRUE to cluster and then gate the experiment.")
        print("********************************************************")
        return()
    }

    if (debugFlag) print("Clustering analysis levels.")
    selC <- readRDS(paste0(projectPath,"/faustData/gateData/",startingCellPop,"_selectedChannels.rds"))
    .clusterLevelsWithScamp(
        startingCellPop = startingCellPop,
        selectedChannels = selC,
        analysisMap = analysisMap,
        numScampIter = numScampIter,
        nameOccuranceNum = nameOccuranceNum,
        debugFlag = debugFlag,
        threadNum = threadNum,
        seedValue = seedValue,
        projectPath = projectPath,
        densitySubSampleThreshold = densitySubSampleThreshold,
        densitySubSampleSize = densitySubSampleSize,
        densitySubSampleIterations = densitySubSampleIterations,
        archDescriptionList=archDescriptionList
    )
    
    if (debugFlag) print("Gating populations.")
    .gateScampClusters(
        startingCellPop = startingCellPop,
        analysisMap = analysisMap,
        selectedChannels = selC,
        debugFlag = debugFlag,
        projectPath = projectPath
    )

    if (debugFlag) print("Generating faust count matrix.")
    .getFaustCountMatrix(
        analysisMap = analysisMap,
        selectedChannels = selC,
        debugFlag = debugFlag,
        projectPath = projectPath
    )

    return()
}

if (getRversion() >= "2.15.1")  utils::globalVariables(c(".","Channel","Quantile","QuantileValue","x","y"))
